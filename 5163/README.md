# 🔐 Certificate Authority Demo System (Root CA + Sub CA + Client)

This project simulates a full Public Key Infrastructure (PKI) system using Python, supporting:
- Root CA certificate creation and revocation management
- Sub CA certificate request via AES-encrypted CSR
- Client certificate request to Sub CA
- TLS mutual authentication between clients
- CRL-based certificate revocation and verification

## 📁 Project Structure

```
.
├── root_ca.py          # Root Certificate Authority logic
├── sub_ca1.py          # First Subordinate CA
├── sub_ca2.py          # Second Subordinate CA (optional for demo)
├── client1.py          # Client 1
├── client2.py          # Client 2
├── cert_registry.json  # Shared certificate registry with revocation info
├── *_cert.pem          # Generated certificate files
├── *_private_key.pem   # Corresponding private keys
├── *_crl.pem           # CRL files generated by CA
├── *_request.enc       # Encrypted CSR request files
```

## ✅ Step-by-Step Testing Guide

### 1️⃣ Start by Initializing Root CA

```bash
python root_ca.py
```

📋 At first launch, this script generates the Root CA certificate and key.  
Then you'll see a **menu interface**. Choose:

- `1` — to view issued certificates (empty at first)
- `3` — to wait for and approve incoming CSR requests from Sub CAs

### 2️⃣ Apply for Certificate from Root CA (as Sub CA)

```bash
python sub_ca1.py
```

Choose:
- `1` — Apply to Root CA via encrypted CSR  
  🔐 An encrypted request file `sub_ca1_request.enc` is created.

Now return to `root_ca.py` and choose:
- `3` — Approve and sign Sub CA request

The signed `sub_ca1_cert.pem` will be generated. Now `sub_ca1` is a valid issuer.

### 3️⃣ Issue Certificate from Sub CA to Client

```bash
python client1.py
```

Choose:
- `1` — Apply for certificate from Sub CA (`sub1`)

An encrypted request file `client1_request.enc` is created.

Now go back to `sub_ca1.py` and choose:
- `2` — Approve client request and issue certificate  
  `client1_cert.pem` is created and added to registry.

### 4️⃣ Test TLS Mutual Authentication Between Clients

You will need **two terminals**:

**Terminal A:**

```bash
python client1.py
```
Choose:
- `2` — Listen mode on port `8443`

**Terminal B:**

```bash
python client2.py
```
Choose:
- `1` — Apply for certificate from `sub1` and get approved by Sub CA
- `3` — Connect to `127.0.0.1`, port `8443`

You’ll see the TLS connection succeed, and can send a message.

### 5️⃣ Test Certificate Revocation (by Sub CA)

In `sub_ca1.py`, choose:
- `3` — Revoke issued certificate (enter: `client1`)

CRL `sub_ca1_crl.pem` is regenerated.

Then try connecting to `client1.py` again.  
💣 TLS handshake will fail due to revoked certificate.

### 6️⃣ Test Sub CA Revocation (by Root CA)

In `root_ca.py`, choose:
- `2` — Revoke certificate (enter: `sub_ca1`)

All certificates issued by Sub CA (e.g., `client1`) will also be **automatically marked revoked** in `cert_registry.json`.

Try using `client1.py` again — you'll see it refuses to connect.

## 🧪 Tested Features

| Feature | Tested |
|--------|--------|
| Root CA key & cert generation | ✅ |
| Sub CA encrypted CSR & signing | ✅ |
| Sub CA issuing client certificates | ✅ |
| AES encryption of CSR | ✅ |
| Mutual TLS between clients | ✅ |
| CRL-based revocation detection | ✅ |
| Sub CA revokes client certs | ✅ |
| Root CA revokes Sub CA + cascade | ✅ |

## 🛠 Requirements

- Python 3.9+
- `cryptography` module

Install via:

```bash
pip install cryptography
```

## 📌 Notes

- The shared `aes_key` is hardcoded for simplicity.
- All files are stored in the working directory.
- You can create more `clientX.py` or `sub_caX.py` files as needed to scale the system.

## 👤 Author

Hongxiang Shao – 33995176 – FIT5163 Assignment
